Глобальная архитектура системы

1. Сама полка представляет из себя техническое устройство, которое присоединяется к Intel Galileo, далее полка.
2. На Intel Galileo имеется приложение, которое взаимодействует с полкой, далее демон.
3. Существует сервер, находящийся на отдельном компьютере, который имеет связь через интернет с платформой Intel Galileo, далее сервер.
4. Имеется приложение на Android, которое взаимодействует с сервером, далее пользовательское приложение.

Подробное описание каждой части.

1. Полка представляет из себя аппаратное устройство, с описанием которого лучше справится Паша, поэтому это мы пропустим.

2. Демон условно можно разделить на 2 части. Первая часть представляет из себя собственно "драйвер" (в кавычках, так как драйвер не полноценный, работает в юзерспейсе в фоновом режиме), который занимается взаимодействием с полкой.
Use-case драйвера:
1. Приём сигнала от полки (предмет поставили в слот, отдельно обрабатывается случай, если предмет впервые оказался в слоте);
2. Приём сигнала от полки (предмет вытащили из слота);
3. Отправка сообщения полке, содержащее в себе ID предмета в системе (функция, принимающая size_t и отправляющая его на полку) для прошивки чипа на предмете;
4. Отправка сигнала о включении светодиода (договоритесь с Пашей, в каком формате, с точки зрения приложения хочется просто иметь функцию diod_on(int), которая принимает id предмета на полке и загорается нужный диод).
Вторая часть отвечает за связь с внешним миром (который для неё будет представлен сервером). Также на Intel Galileo будет своя небольшая мапа, в которой будет храниться актуальная информация (состоять будет из одной таблицы, в которой прописаны зарегистрированные ID, из этой же мапы будет инкрементироваться счётчик следющего предмета). По мапе можно проверить, если предмет, если его нет на месте, то и включать светодиод не требуется. Вторым элементом в мапе будет кодировка (я так понимаю положение на полке определённым образом кодируется, поэтому эту самую кодировку нужно хранить здесь). По факту мапа показывает текущее состояние полки.
Хоть формально демон и является отдельным приложением, на деле работу над ним легко разделить. Этим займёмся мы с Никитой. Предполагаемый язык реализации - C++, хотя можно посмотреть в сторону Python. Основной плюс за плюсы - эффективность, но вообще там придётся писать кучу кода (сокеты) и использовать сторонние библиотеки, в Python всё есть уже. Для Python вроде и mraa и upm реализованы, поэтому можно писать на нём (тем более время поджимает уже).

3. Сервер нужен для того, чтобы осуществлять управление несколькими пользовательскими устройствами, хранить глобальную информацию об имеющихся предметах на полках, а также он выполняет роль посредника между Intel Galileo и приложением Android. Пожалуй, самая сложная с функциональной точки зрения часть.
Начнём с того, что полок может быть много. Поэтому каждая плата Intel Galileo будет иметь свой идентификатор. Он присваивается сервером при регистрации платы. База данных сервера представляет собой две (пока) таблицы, в первой хранится сущность вида {Galileo_ID, Product_ID}, а во второй информация о самом предмете в виде {Product_ID, Name, Additional_Information}. Важно!!! Product_ID совпадает с тем, что плата присваивает предметам на полке и который хранится в её локальной мапе.
Насчёт дополнительных таблиц. Я тут призадумался о безопасности, типа авторизация пользователя и всё такое, но мы это оставим и поэтому просто заведём поле Additional_Information для всяких хэш-сумм, по которым можно будет в будущем отличить пользователя. Можно вообще забить, но лучше оставить пока. 
Use-case:
1. Взаимодействие с Intel Galileo. Можно было бы сделать на REST, тем более, что часть на Intel Galileo будет скорее всего на Python. Однако для обеспечения скорости предлагаю сделать на чистых сокетах. Итак, серверу нужно обеспечить следующий функционал для взаимодействия с платой:
	- приём сообщения о добавлении нового предмета на полку. Формат сообщения - строка вида "<Galileo_ID> <Product_ID>". Сервер должен обеспечить добавление предмета в базу данных. Сначала у предмета отсутствует имя (так с пустым и добавляется);
	- посылка сообщения на плату о включении светодиода на нужном предмете. Формат сообщения "<Product_ID>". На это сообщение нужно дождаться ответа "0" или "1", где "0" означает отсутствие предмета на полке, а "1" - присутствие предмета на полке.
2. Взаимодействие с Android-приложением. Здесь как раз таки можно поднять службу REST и обеспечить протокол общения поверх стандартного HTTP. По факту нужен веб-сервис, который способен обрабатывать следующие запросы:
	- синхронизация (отправляет на приложение названия имеющихся предметов);
	- добавление нового предмета. Так как здесь у нас служба, то взаимодействие оргунизуем в 2 этапа. На первом этапе приложение запрашивает список незарегистрированных предметов, служба возвращает их ID. На втором этапе приложение отправляет запросы на обновление для каждого из адресов ID и присылает службе имя предмета, которое нужно поместить в базу;
	- обновление. По факту второй этап из предыдущего пункта;
	- поиск предмета. Приложение запрашивает поиск предмета по имени, служба возвращает ответ, найден ли предмет, после чего передаёт сигнал на плату о том, что нужно включить светодиод. Здесь важно дождаться ответа от платы, так как предмета может не быть на полке.

Теперь сам протокол взаимодействия службы и приложения.
1. Синхронизация:

Android: GET /sot/status.json
Service: [{id: "id1", name: "Name1"}, {id: "id2", name: "Name2"}, {id: "id3", name: "Name3"}]

2. Добавление:

Android: GET /sot/unregistered.json
Service: ["ID1", "ID2", "ID3"]

<---User edit data--->

Android: POST /sot/new.json?id=<ID>&name=<Name>
Service: ["True"] or ["False"]

3. Обновление:

Android: POST /sot/update.json?id=<ID>&name=<Name>
Service: ["True"] or ["False"]

4. Поиск:

Android: GET /sot/search.json?name=<Name>
Service: ["True"] or ["False"]

Пока без удаления. Думаю, для прототипа этих функций хватит вполне.

Серверной частью занимается Витя. В принципе здесь свобода в выборе технологий, начная от PHP и заканчивая всяким CGI и готовыми фреймворками, типа Django для Python.

4. Android-приложение. Здесь в принципе всё ясно, я не сомневаюсь, что Диман всё чётко сделает. Насчёт интерфейса можно в принципе пописать, но это можно после обсудить. Здесь только технические моменты. В целом главное, что требуется - обеспечить взаимодействие с веб-службой. Протокол выше показан.

Если останется время...

Я вижу 2 относительно простых и несложных расширения:

1. Если предмета нет на месте, но он есть в базе веб службы, то можно зажигать другим светом светодиод, который показывает место, где предмет находился раньше и при этом выдавать звуковой сигнал (опять же заиспользуем зуммер из Комплекта разработчика IoT DevKit).
2. Добавление возможности удаления. Удаление может быть автоматическим и ручным. Автоматическое удаление заключается в том, что сервер опрашивает с определённым интервалом плату на наличие того или иного предмета и держит дату, когда на этот запрос последний раз приходил положительный ответ. Если дата больше 10 дней, то удаляем и всё. Ручное удаление - через интерфейс Android, нужно будет добавить ещё один запрос к службе. В данном случае ничего проверять не требуется, просто удаляем и всё. На работоспособность это никак не повлияет, но чип на предмете можно выбрасывать, если не добавить возможность вытягивать его ID из демона.

Да, здесь ещё не написано про дисплей. Думаю, этим тоже займёмся мы с Никитой, Паша поможет. Я пока не знаю, что туда писать и в каком виде, поэтому ничего конкретного сказать не могу. Я бы вообще дисплей оставил третьим пунктом в разделе Если останется время ... Ну или первым, кому как больше нравится.